<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
    <title>Fleeting Fortune - Cozy Map with Biomes</title>
    <style>
        /* === üß± CSS VARIABLES === */
        :root {
            --theme-bg-primary: linear-gradient(135deg, #1a2a1a, #2d3d20);
            --theme-bg-panel: #3a2818;
            --theme-border-primary: #5d4037;
            --theme-border-accent: #d4af37;
            --theme-text-primary: #e8dcc5;
            --theme-text-gold: #d4af37;
            --panel-padding: 16px;
            --border-radius: 6px;
            --game-padding: 16px;
            --shadow-game: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 0 2px rgba(212, 175, 55, 0.2);
        }

        body {
            margin: 0;
            padding: var(--game-padding);
            font-family: 'Consolas', monospace;
            background: var(--theme-bg-primary);
            color: var(--theme-text-primary);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            width: 100%;
            max-width: 800px;
            height: calc(100dvh - 128px);
            border: 2px solid var(--theme-border-accent);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow-game);
            display: flex;
            flex-direction: column;
            background: #1a2a1a;
            position: relative;
        }

        #mapArea {
            flex: 1;
            background: #1a2a1a;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
            image-rendering: -webkit-optimize-contrast;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .ripple {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--theme-border-accent);
            border-radius: 50%;
            opacity: 0.7;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: ripple-animation 1.0s ease-out forwards;
        }

        @keyframes ripple-animation {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
            }
            100% {
                transform: translate(-50%, -50%) scale(6);
                opacity: 0;
            }
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }

        button {
            background: var(--theme-bg-panel);
            color: var(--theme-text-gold);
            border: 1px solid var(--theme-border-accent);
            padding: 8px 12px;
            font-family: 'Consolas', monospace;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        button:hover {
            background: #4a3a2a;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div id="mapArea">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>
        </div>
        <div class="controls">
            <button id="randomizeBtn">üé≤ Generate Random</button>
        </div>
    </div>

    <script>
        // === üé® BIOME COLOR PALETTE (Easy to tweak!) ===
        const biomePalettes = {
            default: {
                water: '#0a1a3f',    // Deep ocean blue
                plains: '#4b8b3b',   // Lush green
                forest: '#2a5d2a',   // Dark forest green
                mountains: '#a0a0a0' // Gray rock/snow
            },
            desert: {
                water: '#3a3015',    // Muddy oasis
                plains: '#c2b280',   // Sand
                forest: '#8b7e6e',   // Dry scrub
                mountains: '#b8a58f' // Pale stone
            },
            autumn: {
                water: '#1a3a5a',
                plains: '#d46a00',   // Burnt orange
                forest: '#5e3023',   // Crimson
                mountains: '#886655'
            },
            fantasy: {
                water: '#004488',    // Magical blue
                plains: '#44aa44',   // Vibrant green
                forest: '#006644',   // Emerald
                mountains: '#ddaaee' // Purple peaks
            }
        };

        // Current active palette
        let currentPalette = 'default';
        const palette = biomePalettes[currentPalette];

        // === üîß Seeded Random & Noise ===
        function seededRandom(seed) {
            const x = Math.sin(seed * 9283.4) * 10000;
            return x - Math.floor(x);
        }

        function noise2D(x, y, seed) {
            const n = Math.floor(x) + 10000 * Math.floor(y);
            const a = seededRandom(n + seed);
            const b = seededRandom(n + 1 + seed);
            const c = seededRandom(n + 10000 + seed);
            const d = seededRandom(n + 10001 + seed);

            const fx = x - Math.floor(x);
            const fy = y - Math.floor(y);
            const u = fx * fx * (3 - 2 * fx);
            const v = fy * fy * (3 - 2 * fy);

            return a + u * (b - a) + v * (c - a) + u * v * (a - b - c + d);
        }

        // Hex to RGB helper
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        // === üó∫Ô∏è Location Data ===
        const locationTemplates = [
            { id: "commons", name: "The Commons", emoji: "üèòÔ∏è", distanceTier: 1 },
            { id: "wharf", name: "Ocean Wharf", emoji: "‚öì", distanceTier: 2 },
            { id: "cottage", name: "Bramble Cottage", emoji: "üèöÔ∏è", distanceTier: 2 },
            { id: "peak", name: "Dragon's Peak", emoji: "‚õ∞Ô∏è", distanceTier: 4 },
            { id: "forge", name: "Iron Forge", emoji: "‚öíÔ∏è", distanceTier: 2 },
            { id: "sanctum", name: "Crystal Sanctum", emoji: "üîÆ", distanceTier: 3 },
            { id: "crossroads", name: "Dusty Crossroads", emoji: "üõ§Ô∏è", distanceTier: 2 },
            { id: "ruins", name: "Ancient Ruins", emoji: "üèõÔ∏è", distanceTier: 4 }
        ];

        // === üéÆ Game State (Seed is now mutable) ===
        let gameState = null;

        function initializeGame(seed) {
            gameState = {
                seed: seed,
                locations: JSON.parse(JSON.stringify(locationTemplates)),
                connections: {
                    0: [1, 2, 6],
                    1: [0, 3],
                    2: [0, 4, 5],
                    3: [1, 7],
                    4: [2, 6],
                    5: [2, 7],
                    6: [0, 4],
                    7: [3, 5]
                },
                location: 0
            };
        }

        // === üñºÔ∏è Map Renderer ===
        class MapRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext("2d");
                this.hoverIndex = null;
                this.setupCanvas();
                this.positionLocations();
                this.draw();
                this.addEventListeners();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.displayWidth = rect.width;
                this.displayHeight = rect.height;
            }

            drawBiomeBackground() {
                const ctx = this.ctx;
                const width = this.displayWidth;
                const height = this.displayHeight;
                const scale = 0.005;
                const seed = gameState.seed;

                const noiseCanvas = document.createElement("canvas");
                noiseCanvas.width = width;
                noiseCanvas.height = height;
                const noiseCtx = noiseCanvas.getContext("2d");
                const imageData = noiseCtx.createImageData(width, height);
                const data = imageData.data;

                const { water, plains, forest, mountains } = biomePalettes[currentPalette];
                const [wr, wg, wb] = hexToRgb(water);
                const [pr, pg, pb] = hexToRgb(plains);
                const [fr, fg, fb] = hexToRgb(forest);
                const [mr, mg, mb] = hexToRgb(mountains);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const nx = x * scale;
                        const ny = y * scale;
                        let noiseVal = noise2D(nx, ny, seed);
                        noiseVal += 0.5 * noise2D(nx * 2, ny * 2, seed);
                        noiseVal += 0.25 * noise2D(nx * 4, ny * 4, seed);
                        noiseVal /= 1.75;

                        let r, g, b, a = 140;
                        a=255;

                        if (noiseVal < 0.3) {
                            // Water with gentle pulse
                            const pulse = 0.8 + 0.2 * Math.sin(Date.now() * 0.001 + x * 0.005);
                            r = wr * pulse;
                            g = wg * pulse;
                            b = wb * pulse;
                        } else if (noiseVal < 0.5) {
                            // Plains
                            const var1 = 10 * noise2D(nx * 3, ny * 3, seed + 100);
                            r = pr + var1;
                            g = pg + var1;
                            b = pb;
                        } else if (noiseVal < 0.7) {
                            // Forest
                            const var2 = 5 * noise2D(nx * 5, ny * 5, seed + 200);
                            r = fr + var2;
                            g = fg + var2;
                            b = fb;
                        } else {
                            // Mountains
                            const var3 = 20 * noise2D(nx * 6, ny * 6, seed + 300);
                            r = mr + var3;
                            g = mg + var3;
                            b = mb + var3;
                        }

                        const idx = (y * width + x) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = a;
                    }
                }

                noiseCtx.putImageData(imageData, 0, 0);
               // ctx.globalAlpha = 0.5;
                ctx.drawImage(noiseCanvas, 0, 0);
                ctx.globalAlpha = 1.0;

                // Ambient glow
                const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, 1000);
                gradient.addColorStop(0, "rgba(255, 255, 255, 0.0)");
                gradient.addColorStop(1, "rgba(255, 255, 255, 0.08)");
                ctx.fillStyle = gradient;
                //ctx.fillRect(0, 0, width, height);
            }

            positionLocations() {
                const margin = 80;
                const w = this.displayWidth - 2 * margin;
                const h = this.displayHeight - 2 * margin;
                const seed = gameState.seed;

                gameState.locations.forEach((loc, i) => {
                    let biasX = 0.5, biasY = 0.5;

                    if (loc.distanceTier === 4) {
                        const angle = (i * 137.5 + seed) % 360 * Math.PI / 180;
                        biasX = 0.5 + 0.4 * Math.cos(angle);
                        biasY = 0.5 + 0.4 * Math.sin(angle);
                    } else if (loc.distanceTier === 1) {
                        biasX = 0.5 + (seededRandom(seed + i) - 0.5) * 0.1;
                        biasY = 0.5 + (seededRandom(seed + i + 100) - 0.5) * 0.1;
                    } else {
                        biasX = seededRandom(seed + i * 3);
                        biasY = seededRandom(seed + i * 7);
                    }

                    const noiseX = noise2D(biasX * 5, biasY * 5, seed + 10) * 0.2;
                    const noiseY = noise2D(biasX * 5 + 1, biasY * 5, seed + 10) * 0.2;

                    let x = margin + (biasX + noiseX) * w;
                    let y = margin + (biasY + noiseY) * h;

                    x += (seededRandom(seed + i * 17) - 0.5) * 40;
                    y += (seededRandom(seed + i * 19) - 0.5) * 40;

                    loc.x = Math.max(margin, Math.min(this.displayWidth - margin, x));
                    loc.y = Math.max(margin, Math.min(this.displayHeight - margin, y));
                });
            }

            draw() {
                this.ctx.clearRect(0, 0, this.displayWidth, this.displayHeight);
                this.drawBiomeBackground();
                this.drawRoads();
                this.drawLocations();
                if (this.hoverIndex !== null && this.hoverIndex !== gameState.location) {
                    this.drawPathTo(this.hoverIndex);
                }
            }

            drawRoads() {
                this.ctx.strokeStyle = "#8b7355";
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);

                gameState.locations.forEach((from, i) => {
                    const connections = gameState.connections[i] || [];
                    connections.forEach(j => {
                        if (i >= j) return;
                        const to = gameState.locations[j];
                        const midX = (from.x + to.x) / 2;
                        const midY = (from.y + to.y) / 2;
                        const dx = to.x - from.x;
                        const dy = to.y - from.y;
                        const dist = Math.hypot(dx, dy);
                        const perpX = (-dy / dist) * 15;
                        const perpY = (dx / dist) * 15;

                        this.ctx.beginPath();
                        this.ctx.moveTo(from.x, from.y);
                        this.ctx.quadraticCurveTo(midX + perpX, midY + perpY, to.x, to.y);
                        this.ctx.stroke();
                    });
                });
            }

            drawLocations() {
                gameState.locations.forEach((loc, i) => {
                    const isPlayer = i === gameState.location;
                    const radius = 32;
                    this.ctx.beginPath();
                    this.ctx.arc(loc.x, loc.y, radius, 0, Math.PI * 2);
                    this.ctx.fillStyle = isPlayer ? "#4a5a35" : "#2d2d20";
                    this.ctx.fill();
                    this.ctx.strokeStyle = isPlayer ? "#ffd700" : "#6a6a45";
                    this.ctx.lineWidth = isPlayer ? 3 : 1;
                    this.ctx.stroke();

                    this.ctx.font = "24px Consolas";
                    this.ctx.textAlign = "center";
                    this.ctx.textBaseline = "middle";
                    this.ctx.fillStyle = "#f4e4bc";
                    this.ctx.fillText(loc.emoji, loc.x, loc.y);

                    this.ctx.font = "12px Consolas";
                    this.ctx.textBaseline = "top";
                    this.ctx.fillText(loc.name, loc.x, loc.y + radius + 8);
                });
            }

            drawPathTo(targetIndex) {
                const path = this.findPath(gameState.location, targetIndex);
                if (path.length <= 1) return;

                let totalDays = 0;
                for (let i = 1; i < path.length; i++) {
                    totalDays += 1;
                }

                this.ctx.save();
                this.ctx.strokeStyle = "rgba(212, 175, 55, 0.6)";
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 10]);
                this.ctx.lineCap = "round";
                this.ctx.beginPath();
                const start = gameState.locations[path[0]];
                this.ctx.moveTo(start.x, start.y);
                for (let i = 1; i < path.length; i++) {
                    const loc = gameState.locations[path[i]];
                    this.ctx.lineTo(loc.x, loc.y);
                }
                this.ctx.stroke();

                for (let step = 1; step <= totalDays; step++) {
                    const t = step / totalDays;
                    const idx = Math.floor(t * (path.length - 1));
                    const nextIdx = Math.min(idx + 1, path.length - 1);
                    const p1 = gameState.locations[path[idx]];
                    const p2 = gameState.locations[path[nextIdx]];
                    const x = p1.x + (p2.x - p1.x) * (t * (path.length - 1) - idx);
                    const y = p1.y + (p2.y - p1.y) * (t * (path.length - 1) - idx);
                    this.ctx.font = "8px Arial";
                    this.ctx.fillText("‚òÄÔ∏è", x - 8, y - 20);
                }
                this.ctx.restore();
            }

            findPath(start, end) {
                if (start === end) return [start];
                const queue = [[start]];
                const visited = new Set([start]);
                while (queue.length) {
                    const path = queue.shift();
                    const node = path[path.length - 1];
                    for (const neighbor of gameState.connections[node] || []) {
                        if (neighbor === end) return [...path, neighbor];
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([...path, neighbor]);
                        }
                    }
                }
                return [start];
            }

            addEventListeners() {
                this.canvas.addEventListener("mousemove", (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    let hovered = null;

                    gameState.locations.forEach((loc, i) => {
                        const dist = Math.hypot(x - loc.x, y - loc.y);
                        if (dist <= 40 && i !== gameState.location) {
                            hovered = i;
                            this.canvas.style.cursor = "pointer";
                        }
                    });

                    if (hovered !== this.hoverIndex) {
                        this.hoverIndex = hovered;
                        this.draw();
                    }

                    if (hovered === null && this.canvas.style.cursor !== "default") {
                        this.canvas.style.cursor = "default";
                    }
                });

                this.canvas.addEventListener("click", (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    gameState.locations.forEach((loc, i) => {
                        const dist = Math.hypot(x - loc.x, y - loc.y);
                        if (dist <= 40) {
                            const ripple = document.createElement("div");
                            ripple.classList.add("ripple");
                            ripple.style.left = `${loc.x}px`;
                            ripple.style.top = `${loc.y}px`;
                            this.canvas.parentElement.appendChild(ripple);
                            setTimeout(() => ripple.remove(), 1500);
                            console.log(`Clicked: ${loc.name}`);
                        }
                    });
                });
            }
        }

        // === üîÅ Randomize Function ===
        function generateNewWorld() {
            const newSeed = Math.floor(Math.random() * 100000);
            currentPalette = Object.keys(biomePalettes)[
                Math.floor(Math.random() * Object.keys(biomePalettes).length)
            ]; // Optional: Random palette
            initializeGame(newSeed);
            const canvas = document.getElementById("canvas");
            new MapRenderer(canvas);
        }

        // === üöÄ Init ===
        window.addEventListener("load", () => {
            initializeGame(Math.floor(Math.random() * 100000));
            new MapRenderer(document.getElementById("canvas"));

            // Add random button listener
            document.getElementById("randomizeBtn").addEventListener("click", generateNewWorld);
        });
    </script>
</body>

</html>