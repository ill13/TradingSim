All files from 'TradingGame'
Generated: 2025-08-31 09:58:16
Mode: all
Included extensions: yaml, py, scss, ts, ini, jsx, js, jpeg, png, vue, cfg, html, sass, css, yml, jpg, tiff, toml, webp, less, tsx, svg, gif, bmp, txt, json
Tiktoken available: True
Encoding: cl100k_base
==================================================

==================================================
FILE: game_data.json
MODIFIED: 2025-08-29 18:20:20
TOKENS: [92m1,426[0m
==================================================

{
  "items": [
    { "id": "fish", "name": "Fish", "emoji": "🐟", "category": "basic", "basePrice": 8 },
    { "id": "herbs", "name": "Herbs", "emoji": "🌿", "category": "basic", "basePrice": 12 },
    { "id": "grain", "name": "Grain", "emoji": "🌾", "category": "basic", "basePrice": 6 },
    { "id": "tools", "name": "Tools", "emoji": "🔨", "category": "quality", "basePrice": 20 },
    { "id": "cloth", "name": "Cloth", "emoji": "🧵", "category": "quality", "basePrice": 15 },
    { "id": "pottery", "name": "Pottery", "emoji": "🏺", "category": "quality", "basePrice": 18 },
    { "id": "gems", "name": "Gems", "emoji": "💎", "category": "premium", "basePrice": 45 },
    { "id": "artifacts", "name": "Artifacts", "emoji": "🗿", "category": "premium", "basePrice": 55 },
    { "id": "spices", "name": "Spices", "emoji": "🌶️", "category": "premium", "basePrice": 35 }
  ],
  "locationTemplates": [
    { 
      "id": "commons", 
      "name": "The Commons", 
      "emoji": "🏘️",
      "description": "A bustling village square where locals gather to trade daily necessities",
      "flavorText": "\"Fair prices for honest folk\"",
      "multipliers": { "basic": 0.9, "quality": 1.0, "premium": 1.3 },
      "travelTime" : 1,
      "distanceTier": 1
    },
    { 
      "id": "wharf", 
      "name": "Ocean Wharf", 
      "emoji": "⚓",
      "description": "A busy harbor where merchant ships bring fresh catches and exotic goods",
      "flavorText": "\"Fresh from the morning nets\"",
      "multipliers": { "basic": 0.7, "quality": 1.1, "premium": 1.4 },
      "travelTime" : 2,
      "distanceTier": 2
    },
    { 
      "id": "cottage", 
      "name": "Bramble Cottage", 
      "emoji": "🏚️",
      "description": "An herbalist's home surrounded by wild gardens and drying racks",
      "flavorText": "\"Picked at dawn when the magic is strongest\"",
      "multipliers": { "basic": 0.8, "quality": 1.3, "premium": 1.1 },
       "travelTime" : 1,
       "distanceTier": 2
    },
    { 
      "id": "peak", 
      "name": "Dragon's Peak", 
      "emoji": "⛰️",
      "description": "A treacherous mountain settlement where treasures are as dangerous as they are valuable",
      "flavorText": "\"Fortune favors the bold, but demands its price\"",
      "multipliers": { "basic": 1.4, "quality": 1.2, "premium": 0.8 },
       "travelTime" : 2,
       "distanceTier": 4
    },
    { 
      "id": "forge", 
      "name": "Iron Forge", 
      "emoji": "⚒️",
      "description": "A smoky workshop where skilled artisans craft tools and trade materials",
      "flavorText": "\"Forged with skill, built to last\"",
      "multipliers": { "basic": 1.1, "quality": 0.8, "premium": 1.2 }, 
      "travelTime" : 1,
      "distanceTier": 2
    },
    { 
      "id": "sanctum", 
      "name": "Crystal Sanctum", 
      "emoji": "🔮",
      "description": "A mysterious tower where scholars study ancient artifacts and rare minerals",
      "flavorText": "\"Knowledge is the rarest treasure of all\"",
      "multipliers": { "basic": 1.2, "quality": 1.1, "premium": 0.9 },
      "travelTime" : 1,
      "distanceTier": 3
    },
    { 
      "id": "crossroads", 
      "name": "Dusty Crossroads", 
      "emoji": "🛤️",
      "description": "A remote trading post where weary travelers rest and merchants meet",
      "flavorText": "\"All roads lead somewhere, all trades lead here\"",
      "multipliers": { "basic": 1.0, "quality": 1.0, "premium": 1.0 },
      "travelTime" : 1,
      "distanceTier": 2
    },
    { 
      "id": "ruins", 
      "name": "Ancient Ruins", 
      "emoji": "🏛️",
      "description": "Crumbling stones hide forgotten treasures and desperate scavengers",
      "flavorText": "\"What the old world lost, the new world seeks\"",
      "multipliers": { "basic": 1.3, "quality": 1.4, "premium": 0.7 },
      "travelTime" : 1,
      "distanceTier": 4
    }
  ],
  "categoryLabels": {
    "basic": "Common",
    "quality": "Crafted", 
    "premium": "Rare"
  },
  "genericNews": [
    "🎪 Traveling merchants report good business along the trade routes",
    "⛈️ Storm clouds gathering - sailors speak of rough seas ahead",
    "🎭 Festival season brings new opportunities to the markets",
    "📈 Trade guilds opening new routes through the eastern passes",
    "🌾 Harvest reports vary wildly from region to region",
    "⚔️ Rumors of bandits on the mountain roads grow stronger",
    "🔥 The forges burn bright with increased demand for tools",
    "🌙 Night merchants whisper of rare finds in distant ruins"
  ]
}

==================================================
FILE: game_rules.json
MODIFIED: 2025-08-31 00:55:26
TOKENS: [92m218[0m
==================================================

{
    "gameplay": {
        "maxDays": 30,
        "startingGold": 100,
        "inventoryLimit": 20
    },
    "grid": {
        "width": 32,
        "height": 32
    },
    "worldGeneration": {
        "minLocations": 3,
        "maxLocations": 8
    },
    "pricing": {
        "seasonal": {
            "min": 0.8,
            "range": 0.4
        },
        "daily": {
            "min": 0.9,
            "range": 0.2
        },
        "saturation": {
            "threshold": 3,
            "penaltyRate": 0.3,
            "decayRate": 0.3,
            "maxSaturation": 5,
            "buyingSaturationRate": 0.5
        }
    },
    "stock": {
        "minStock": 5,
        "stockRange": 15
    }
}

==================================================
FILE: index.html
MODIFIED: 2025-08-31 09:50:00
TOKENS: [92m12,850[0m
==================================================

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fleeting Fortune</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div class="game-container">
      <div class="header">
        <div class="header-left">
          <div style="font-size: 1.8rem; filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.5))">🏛️</div>
          <div class="location-display">
            <div class="location-name" id="location">Market Square</div>
            <div class="location-subtitle">Current Location</div>
          </div>
        </div>
        <div class="header-stats">
          <div class="stat-item"><span class="stat-label">Day</span> <span class="stat-value" id="day">1</span>/<span class="stat-value">30</span></div>
          <div class="stat-item"><span class="stat-label">Gold:</span> <span class="stat-value" id="gold">100</span></div>
          <div class="stat-item"><span class="stat-label">Inv</span> <span class="stat-value" id="inventoryCount">0/15</span></div>
        </div>
      </div>

      <!-- Map Screen -->
      <div id="mapScreen" class="screen">
        <div id="mapArea">
          <canvas id="canvas"></canvas>
        </div>
        <div class="panels">
          <div class="panel news-panel">
            <h3>📰 Village News & Market Gossip</h3>
            <div class="panel-content">
              <div id="news"></div>
            </div>
          </div>
          <div class="panel inventory-panel">
            <h3>🎒 Your Inventory <span class="inventory-count" id="inventoryCount">0/15</span></h3>
            <div class="panel-content">
              <div id="inventory"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Enhanced Trading Screen -->
      <div id="tradingScreen" class="screen trading-screen hidden">
        <h2 id="locationTitle" hidden>Trading Post</h2>

        <!-- Inventory Status -->
        <div class="quest-hint" id="questHint">Quest: Deliver 3 Herbs to Dragon's Peak</div>
        <!-- <div class="inventory-status">
          <div class="inventory-space" id="inventoryStatus">Inventory: 0/15 items</div> 
          
        </div> -->

        <!-- Market Insight -->
        <div id="marketInsight" class="market-insight">
          <span style="font-size: 1.2rem">💡</span>
          <span style="font-weight: bold" id="insightText">Market analysis loading...</span>
        </div>

        <!-- Items Container - scrollable -->
        <div class="items-container">
          <div id="items"></div>
        </div>

        <!-- Footer -->
        <div class="trading-footer">
          <button class="btn btn-back" onclick="showMap()">Back to Map</button>
        </div>
      </div>

      <!-- Game Over -->
      <div id="gameOver" class="game-over">
        <div>
          <h2>Season Complete!</h2>
          <div>Final Profit: <span id="profit">0</span> gold</div>
          <button class="btn btn-primary" onclick="resetGame()">Play Again</button>
        </div>
      </div>
    </div>

    <script>
      // Game State
      const game = {
        day: 1,
        gold: 100,
        location: 0,
        inventory: [],
        prices: {},
        stock: {},
        saturation: {},
        locations: [],
        locationGrid: [],
        items: [],
        quests: [],
        achievements: [],
        currentQuest: null,
        unlockedAchievements: new Set(),
        seed: Date.now() % 10000,
        rules: null,
        gameData: null,
      };

      // GameState wrapper class
      class GameState {
        constructor(gameObj) {
          this.game = gameObj;
        }

        updateGold(amount) {
          this.game.gold += amount;
        }

        setGold(amount) {
          this.game.gold = amount;
        }

        updateDay(amount = 1) {
          this.game.day += amount;
        }

        setLocation(locationIndex) {
          this.game.location = locationIndex;
        }

        updateStock(itemId, amount) {
          this.game.stock[itemId] = (this.game.stock[itemId] || 0) + amount;
        }

        setStock(itemId, amount) {
          this.game.stock[itemId] = amount;
        }

        addToInventory(itemId, quantity, price) {
          for (let i = 0; i < quantity; i++) {
            this.game.inventory.push({ id: itemId, price: price });
          }
        }

        removeFromInventory(itemId, quantity) {
          for (let i = 0; i < quantity; i++) {
            const index = this.game.inventory.findIndex((item) => item.id === itemId);
            if (index !== -1) {
              this.game.inventory.splice(index, 1);
            }
          }
        }

        clearInventory() {
          this.game.inventory = [];
        }

        // Inside the GameState class
        getAveragePurchasePrice(itemId) {
          const items = this.game.inventory.filter((item) => item.id === itemId);
          if (items.length === 0) return null;

          const totalCost = items.reduce((sum, item) => sum + item.price, 0);
          return Math.round(totalCost / items.length);
        }

        updateSaturation(key, amount) {
          this.game.saturation[key] = (this.game.saturation[key] || 0) + amount;
        }

        setSaturation(key, amount) {
          this.game.saturation[key] = amount;
        }

        clearSaturation(key) {
          delete this.game.saturation[key];
        }

        decaySaturation() {
          const decayRate = this.game.rules.pricing.saturation.decayRate;
          Object.keys(this.game.saturation).forEach((key) => {
            this.game.saturation[key] = Math.max(0, this.game.saturation[key] - decayRate);
            if (this.game.saturation[key] === 0) {
              this.clearSaturation(key);
            }
          });
        }

        setPrices(prices) {
          this.game.prices = prices;
        }

        setPrice(itemId, price) {
          this.game.prices[itemId] = price;
        }

        setSeed(seed) {
          this.game.seed = seed;
        }

        reset() {
          this.game.day = 1;
          this.game.gold = this.game.rules.gameplay.startingGold;
          this.game.location = 0;
          this.game.inventory = [];
          this.game.saturation = {};
          this.game.currentQuest = null;
          this.game.seed = Date.now() % 10000;
        }

        // Getter methods for controlled access
        getPrice(itemId) {
          return this.game.prices[itemId];
        }

        getStock(itemId) {
          return this.game.stock[itemId] || 0;
        }

        getSaturation(key) {
          return this.game.saturation[key] || 0;
        }

        getInventorySpace() {
          return this.game.rules.gameplay.inventoryLimit - this.game.inventory.length;
        }

        getItem(itemId) {
          return this.game.items.find((i) => i.id === itemId);
        }

        getLocation(index) {
          return this.game.locations[index];
        }

        getCurrentLocation() {
          return this.game.locations[this.game.location];
        }

        getInventoryCount(itemId) {
          return this.game.inventory.filter((item) => item.id === itemId).length;
        }

        getGold() {
          return this.game.gold;
        }

        // Quest methods
        setQuest(quest) {
          this.game.currentQuest = quest;
        }

        updateQuestDelivered(amount) {
          if (this.game.currentQuest) {
            this.game.currentQuest.delivered += amount;
          }
        }

        completeQuest() {
          this.game.currentQuest = null;
        }
      }

      // Create GameState instance
      const gameState = new GameState(game);

      // Grid system utilities
      class GridSystem {
        static findLocationPosition(locationIndex) {
          for (let y = 0; y < gameState.game.locationGrid.length; y++) {
            for (let x = 0; x < gameState.game.locationGrid[y].length; x++) {
              if (gameState.game.locationGrid[y][x] === locationIndex) {
                return { x, y };
              }
            }
          }
          return null;
        }

        static areAdjacent(locIndexA, locIndexB) {
          const posA = this.findLocationPosition(locIndexA);
          const posB = this.findLocationPosition(locIndexB);
          if (!posA || !posB) return false;

          const dx = Math.abs(posA.x - posB.x);
          const dy = Math.abs(posA.y - posB.y);
          return dx <= 1 && dy <= 1 && dx + dy > 0;
        }

        static getGridDistance(locIndexA, locIndexB) {
          const posA = this.findLocationPosition(locIndexA);
          const posB = this.findLocationPosition(locIndexB);
          if (!posA || !posB) return Infinity;

          return Math.abs(posA.x - posB.x) + Math.abs(posA.y - posB.y);
        }

        static findPath(fromIndex, toIndex) {
          // Simple A* pathfinding implementation
          const start = this.findLocationPosition(fromIndex);
          const goal = this.findLocationPosition(toIndex);
          if (!start || !goal) return [];

          const openSet = [{ x: start.x, y: start.y, g: 0, f: 0, parent: null }];
          const closedSet = [];
          const gridWidth = gameState.game.rules.grid.width;
          const gridHeight = gameState.game.rules.grid.height;

          while (openSet.length > 0) {
            // Get node with lowest f score
            let current = openSet[0];
            let currentIndex = 0;
            for (let i = 1; i < openSet.length; i++) {
              if (openSet[i].f < current.f) {
                current = openSet[i];
                currentIndex = i;
              }
            }

            // Remove from open set, add to closed set
            openSet.splice(currentIndex, 1);
            closedSet.push(current);

            // Found goal
            if (current.x === goal.x && current.y === goal.y) {
              const path = [];
              let node = current;
              while (node) {
                const locationIndex = gameState.game.locationGrid[node.y][node.x];
                if (locationIndex !== null) {
                  path.unshift(locationIndex);
                }
                node = node.parent;
              }
              return path;
            }

            // Check neighbors
            const neighbors = [
              { x: current.x - 1, y: current.y },
              { x: current.x + 1, y: current.y },
              { x: current.x, y: current.y - 1 },
              { x: current.x, y: current.y + 1 },
            ];

            for (const neighbor of neighbors) {
              if (neighbor.x < 0 || neighbor.x >= gridWidth || neighbor.y < 0 || neighbor.y >= gridHeight) continue;

              if (closedSet.find((n) => n.x === neighbor.x && n.y === neighbor.y)) continue;

              const g = current.g + 1;
              const h = Math.abs(neighbor.x - goal.x) + Math.abs(neighbor.y - goal.y);
              const f = g + h;

              const existing = openSet.find((n) => n.x === neighbor.x && n.y === neighbor.y);
              if (!existing) {
                openSet.push({ x: neighbor.x, y: neighbor.y, g, h, f, parent: current });
              } else if (g < existing.g) {
                existing.g = g;
                existing.f = g + existing.h;
                existing.parent = current;
              }
            }
          }

          return []; // No path found
        }
      }

      // Quest system
      class QuestLogic {
        static generateQuest(currentLocationIndex, baseSeed, currentDay) {
          let seedRng = baseSeed + 1;
          function seededRandom() {
            seedRng = (seedRng * 9301 + 49297) % 233280;
            return seedRng / 233280;
          }

          // Pick random item
          const item = gameState.game.items[Math.floor(seededRandom() * gameState.game.items.length)];

          // Find valid target locations (expensive or doesn't sell item)
          const validTargets = [];
          gameState.game.locations.forEach((location, index) => {
            if (index === currentLocationIndex) return; // Can't target current location

            const multiplier = location.multipliers[item.category] || 1.0;
            if (multiplier >= 1.2) {
              // Expensive enough
              validTargets.push(location);
            }
          });

          if (validTargets.length === 0) {
            // Fallback to any location except current
            validTargets.push(...gameState.game.locations.filter((_, i) => i !== currentLocationIndex));
          }

          const targetLocation = validTargets[Math.floor(seededRandom() * validTargets.length)];

          // Set quantity based on category
          let quantity;
          switch (item.category) {
            case "basic":
              quantity = Math.floor(seededRandom() * 3) + 3;
              break; // 3-5
            case "quality":
              quantity = Math.floor(seededRandom() * 3) + 2;
              break; // 2-4
            case "premium":
              quantity = Math.floor(seededRandom() * 2) + 1;
              break; // 1-2
            default:
              quantity = 3;
          }

          const reward = item.basePrice * quantity * 1.5; // 50% bonus over base value

          return {
            itemId: item.id,
            targetLocationName: targetLocation.name,
            quantity: quantity,
            delivered: 0,
            reward: Math.round(reward),
          };
        }

        static checkQuestDelivery() {
          if (!gameState.game.currentQuest) return;

          const currentLocationName = gameState.game.locations[gameState.game.location].name;
          if (currentLocationName !== gameState.game.currentQuest.targetLocationName) return;

          const questItemCount = gameState.getInventoryCount(gameState.game.currentQuest.itemId);
          if (questItemCount === 0) return;

          const deliverAmount = Math.min(questItemCount, gameState.game.currentQuest.quantity - gameState.game.currentQuest.delivered);

          // Remove items from inventory
          gameState.removeFromInventory(gameState.game.currentQuest.itemId, deliverAmount);

          // Update quest progress
          gameState.updateQuestDelivered(deliverAmount);

          // Check if quest completed
          if (gameState.game.currentQuest.delivered >= gameState.game.currentQuest.quantity) {
            gameState.updateGold(gameState.game.currentQuest.reward);
            gameState.completeQuest();

            // Generate new quest
            const newQuest = QuestLogic.generateQuest(gameState.game.location, gameState.game.seed, gameState.game.day);
            gameState.setQuest(newQuest);
          }
        }
      }

      // Market Logic - Business rules only, no state mutations
      class MarketLogic {
        static generatePrices() {
          const rules = gameState.game.rules.pricing;
          const SEASONAL_MIN = rules.seasonal.min;
          const SEASONAL_RANGE = rules.seasonal.range;
          const DAILY_MIN = rules.daily.min;
          const DAILY_RANGE = rules.daily.range;

          const prices = {};
          gameState.game.items.forEach((item) => {
            const base = item.basePrice;
            const seasonal = SEASONAL_MIN + Math.random() * SEASONAL_RANGE;
            const daily = DAILY_MIN + Math.random() * DAILY_RANGE;
            prices[item.id] = Math.round(base * seasonal * daily);
          });
          return prices;
        }

        static generateStock() {
          const rules = gameState.game.rules.stock;
          const MIN_STOCK = rules.minStock;
          const STOCK_RANGE = rules.stockRange;

          const stock = {};
          gameState.game.items.forEach((item) => {
            stock[item.id] = Math.floor(Math.random() * STOCK_RANGE) + MIN_STOCK;
          });
          return stock;
        }

        static getPrice(itemId, locationId) {
          const rules = gameState.game.rules.pricing.saturation;
          const SATURATION_THRESHOLD = rules.threshold;
          const SATURATION_PENALTY_RATE = rules.penaltyRate;
          const DEFAULT_MULTIPLIER = 1;

          const item = gameState.getItem(itemId);
          const location = gameState.getLocation(locationId);
          const basePrice = gameState.getPrice(itemId);
          const locationMultiplier = location.multipliers[item.category] || DEFAULT_MULTIPLIER;

          // Apply market saturation - affects both buying and selling
          const saturationKey = `${locationId}-${itemId}`;
          const saturationLevel = gameState.getSaturation(saturationKey);

          let marketAdjustment = 1.0;
          if (saturationLevel >= SATURATION_THRESHOLD) {
            // Linear price reduction based on oversaturation
            const excessSaturation = saturationLevel - SATURATION_THRESHOLD;
            marketAdjustment = 1.0 - SATURATION_PENALTY_RATE * (1 + excessSaturation * 0.2);
            marketAdjustment = Math.max(0.4, marketAdjustment); // Floor at 60% discount
          }

          const finalPrice = basePrice * locationMultiplier * marketAdjustment;
          return Math.round(finalPrice);
        }

        static canBuy(itemId, quantity) {
          const price = this.getPrice(itemId, gameState.game.location);
          const cost = price * quantity;
          const available = gameState.getStock(itemId);
          const space = gameState.getInventorySpace();

          return cost <= gameState.getGold() && quantity <= available && quantity <= space;
        }

        static canSell(itemId, quantity) {
          const owned = gameState.getInventoryCount(itemId);
          return quantity <= owned;
        }

        static getMaxBuyQuantity(itemId) {
          const price = this.getPrice(itemId, gameState.game.location);
          const affordable = Math.floor(gameState.getGold() / price);
          const available = gameState.getStock(itemId);
          const space = gameState.getInventorySpace();
          return Math.min(affordable, available, space);
        }

        static getMaxSellQuantity(itemId) {
          return gameState.getInventoryCount(itemId);
        }

        static getDealQuality(itemId) {
          const item = gameState.getItem(itemId);
          const location = gameState.getCurrentLocation();
          const multiplier = location.multipliers[item.category] || 1.0;

          if (multiplier <= 0.8) return "great";
          if (multiplier <= 0.9) return "good";
          if (multiplier >= 1.3) return "poor";
          return "fair";
        }
      }

      // Market Actions - State mutations only, trusts caller did validation
      class MarketActions {
        static sell(itemId, quantity) {
          const price = MarketLogic.getPrice(itemId, gameState.game.location);

          gameState.removeFromInventory(itemId, quantity);
          gameState.updateGold(price * quantity);

          // Add selling saturation for large sales
          const rules = gameState.game.rules.pricing.saturation;
          if (quantity >= rules.threshold) {
            const satKey = `${gameState.game.location}-${itemId}`;
            const currentSaturation = gameState.getSaturation(satKey);
            const newSaturation = Math.min(rules.maxSaturation, currentSaturation + quantity);
            gameState.setSaturation(satKey, newSaturation);
          }
        }

        static buy(itemId, quantity) {
          const price = MarketLogic.getPrice(itemId, gameState.game.location);
          const cost = price * quantity;

          gameState.updateGold(-cost);
          gameState.updateStock(itemId, -quantity);
          gameState.addToInventory(itemId, quantity, price);

          // Add buying saturation for large purchases
          const rules = gameState.game.rules.pricing.saturation;
          if (quantity >= rules.threshold) {
            const satKey = `${gameState.game.location}-${itemId}`;
            const buyingSaturation = quantity * rules.buyingSaturationRate;
            const currentSaturation = gameState.getSaturation(satKey);
            const newSaturation = Math.min(rules.maxSaturation, currentSaturation + buyingSaturation);
            gameState.setSaturation(satKey, newSaturation);
          }
        }

        static updatePrices() {
          const prices = MarketLogic.generatePrices();
          gameState.setPrices(prices);
        }

        static updateStock() {
          const stock = MarketLogic.generateStock();
          Object.entries(stock).forEach(([itemId, amount]) => {
            gameState.setStock(itemId, amount);
          });
        }
      }

      // Map Renderer - Fixed version
      class MapRenderer_old {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");

          // Event listeners
          canvas.addEventListener("click", this.handleClick.bind(this));
          canvas.addEventListener("mousemove", this.handleMouseMove.bind(this));

          // Handle window resize
          window.addEventListener("resize", () => {
            this.updateCanvasSize();
            this.positionLocations();
            this.draw();
          });

          // Defer initial setup to ensure DOM is ready
          requestAnimationFrame(() => {
            this.updateCanvasSize();
            this.positionLocations();
            this.draw();
          });
        }

        updateCanvasSize() {
          const rect = this.canvas.getBoundingClientRect();

          // Set canvas internal resolution to match display size
          const dpr = window.devicePixelRatio || 1;
          this.canvas.width = rect.width * dpr;
          this.canvas.height = rect.height * dpr;

          // Scale context to match device pixel ratio
          this.ctx.scale(dpr, dpr);

          // Store display dimensions for calculations
          this.displayWidth = rect.width;
          this.displayHeight = rect.height;
        }

        positionLocations() {
          const margin = 80;
          const w = this.displayWidth - 2 * margin;
          const h = this.displayHeight - 2 * margin;
          const minSeparation = 100; // Minimum distance between locations

          gameState.game.locations.forEach((location, i) => {
            const gridPos = GridSystem.findLocationPosition(i);
            if (gridPos) {
              const gridWidth = gameState.game.rules.grid.width;
              const gridHeight = gameState.game.rules.grid.height;

              // Convert grid coordinates to canvas coordinates
              let x = margin + (gridPos.x / (gridWidth - 1)) * w;
              let y = margin + (gridPos.y / (gridHeight - 1)) * h;

              // Add deterministic offset for natural appearance
              const locationSeed = gameState.game.seed + i * 17;
              const pseudoRand1 = ((locationSeed * 9301 + 49297) % 233280) / 233280;
              const pseudoRand2 = (((locationSeed + 1) * 9301 + 49297) % 233280) / 233280;

              const offset = 30;
              x += (pseudoRand1 - 0.5) * offset;
              y += (pseudoRand2 - 0.5) * offset;

              // Ensure minimum separation from other locations
              let attempts = 0;
              while (attempts < 50) {
                let tooClose = false;
                for (let j = 0; j < i; j++) {
                  const other = gameState.game.locations[j];
                  if (other.x !== undefined && other.y !== undefined) {
                    const dist = Math.sqrt((x - other.x) ** 2 + (y - other.y) ** 2);
                    if (dist < minSeparation) {
                      tooClose = true;
                      break;
                    }
                  }
                }

                if (!tooClose) break;

                // Try a new position with larger offset
                const newSeed = locationSeed + attempts * 7;
                const newRand1 = ((newSeed * 9301 + 49297) % 233280) / 233280;
                const newRand2 = (((newSeed + 1) * 9301 + 49297) % 233280) / 233280;

                x = margin + (gridPos.x / (gridWidth - 1)) * w;
                y = margin + (gridPos.y / (gridHeight - 1)) * h;
                x += (newRand1 - 0.5) * (offset + attempts * 10);
                y += (newRand2 - 0.5) * (offset + attempts * 10);

                attempts++;
              }

              // Keep in bounds with padding for click radius
              location.x = Math.max(margin + 50, Math.min(this.displayWidth - margin - 50, x));
              location.y = Math.max(margin + 50, Math.min(this.displayHeight - margin - 50, y));
            }
          });
        }

        draw() {
          // Clear with proper dimensions
          this.ctx.clearRect(0, 0, this.displayWidth, this.displayHeight);

          // Draw roads
          this.drawRoads();

          // Draw locations
          gameState.game.locations.forEach((location, i) => {
            const isPlayer = i === gameState.game.location;
            const radius = 40;

            // Circle
            this.ctx.beginPath();
            this.ctx.arc(location.x, location.y, radius, 0, Math.PI * 2);
            this.ctx.fillStyle = isPlayer ? "#4a5a35" : "#2d2d20";
            this.ctx.fill();
            this.ctx.strokeStyle = isPlayer ? "#ffd700" : "#6a6a45";
            this.ctx.lineWidth = isPlayer ? 3 : 1;
            this.ctx.stroke();

            // Emoji
            this.ctx.font = "24px Arial";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillStyle = "#f4e4bc";
            this.ctx.fillText(location.emoji, location.x, location.y);

            // Name
            this.ctx.font = "bold 14px Arial";
            this.ctx.textBaseline = "top";
            this.ctx.fillText(location.name, location.x, location.y + radius + 8);
          });
        }

        drawRoads() {
          this.ctx.strokeStyle = "#8b7355";
          this.ctx.lineWidth = 2;

          // Connect each location to 2-3 nearest neighbors for visual splines
          gameState.game.locations.forEach((from, i) => {
            const distances = gameState.game.locations
              .map((to, j) => ({
                index: j,
                dist: Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2),
              }))
              .filter((d) => d.index !== i)
              .sort((a, b) => a.dist - b.dist)
              .slice(0, 2);

            distances.forEach(({ index }) => {
              const to = gameState.game.locations[index];

              // Draw curved road
              const midX = (from.x + to.x) / 2;
              const midY = (from.y + to.y) / 2;
              const dx = to.x - from.x;
              const dy = to.y - from.y;
              const dist = Math.sqrt(dx * dx + dy * dy);

              const perpX = (-dy / dist) * 20;
              const perpY = (dx / dist) * 20;

              this.ctx.beginPath();
              this.ctx.moveTo(from.x, from.y);
              this.ctx.quadraticCurveTo(midX + perpX, midY + perpY, to.x, to.y);
              this.ctx.stroke();
            });
          });
        }

        handleClick(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          gameState.game.locations.forEach((location, i) => {
            const dist = Math.sqrt((x - location.x) ** 2 + (y - location.y) ** 2);
            if (dist <= 40) {
              if (i !== gameState.game.location) {
                travel(i);
              } else {
                enterLocation(i);
              }
            }
          });
        }

        handleMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          let hoverLocation = null;
          gameState.game.locations.forEach((location, i) => {
            const dist = Math.sqrt((x - location.x) ** 2 + (y - location.y) ** 2);
            if (dist <= 40 && i !== gameState.game.location) {
              hoverLocation = i;
            }
          });

          if (hoverLocation !== null) {
            const travelTime = GridSystem.getGridDistance(gameState.game.location, hoverLocation);
            this.canvas.title = `${gameState.game.locations[hoverLocation].name} - ${travelTime} days travel`;
            this.canvas.style.cursor = "pointer";
          } else {
            this.canvas.title = "";
            this.canvas.style.cursor = "default";
          }
        }
      }

      // Map Renderer - Enhanced with Visual Travel Paths & Custom Tooltip
      class MapRenderer {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
          this.hoverLocation = null; // Track hover state

          // Event listeners
          canvas.addEventListener("click", this.handleClick.bind(this));
          canvas.addEventListener("mousemove", this.handleMouseMove.bind(this));
          canvas.addEventListener("mouseout", () => {
            this.hoverLocation = null;
            this.canvas.title = "";
            this.canvas.style.cursor = "default";
            this.draw(); // Redraw without hover effects
          });

          // Handle window resize
          window.addEventListener("resize", () => {
            this.updateCanvasSize();
            this.positionLocations();
            this.draw();
          });

          // Defer initial setup
          requestAnimationFrame(() => {
            this.updateCanvasSize();
            this.positionLocations();
            this.draw();
          });
        }

        updateCanvasSize() {
          const rect = this.canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;
          this.canvas.width = rect.width * dpr;
          this.canvas.height = rect.height * dpr;
          this.ctx.scale(dpr, dpr);
          this.displayWidth = rect.width;
          this.displayHeight = rect.height;
        }

        positionLocations() {
          const margin = 80;
          const w = this.displayWidth - 2 * margin;
          const h = this.displayHeight - 2 * margin;
          const minSeparation = 100;
          gameState.game.locations.forEach((location, i) => {
            const gridPos = GridSystem.findLocationPosition(i);
            if (gridPos) {
              const gridWidth = gameState.game.rules.grid.width;
              const gridHeight = gameState.game.rules.grid.height;
              let x = margin + (gridPos.x / (gridWidth - 1)) * w;
              let y = margin + (gridPos.y / (gridHeight - 1)) * h;

              const locationSeed = gameState.game.seed + i * 17;
              const pseudoRand1 = ((locationSeed * 9301 + 49297) % 233280) / 233280;
              const pseudoRand2 = (((locationSeed + 1) * 9301 + 49297) % 233280) / 233280;
              const offset = 30;
              x += (pseudoRand1 - 0.5) * offset;
              y += (pseudoRand2 - 0.5) * offset;

              let attempts = 0;
              while (attempts < 50) {
                let tooClose = false;
                for (let j = 0; j < i; j++) {
                  const other = gameState.game.locations[j];
                  if (other.x !== undefined && other.y !== undefined) {
                    const dist = Math.sqrt((x - other.x) ** 2 + (y - other.y) ** 2);
                    if (dist < minSeparation) {
                      tooClose = true;
                      break;
                    }
                  }
                }
                if (!tooClose) break;
                const newSeed = locationSeed + attempts * 7;
                const newRand1 = ((newSeed * 9301 + 49297) % 233280) / 233280;
                const newRand2 = (((newSeed + 1) * 9301 + 49297) % 233280) / 233280;
                x = margin + (gridPos.x / (gridWidth - 1)) * w;
                y = margin + (gridPos.y / (gridHeight - 1)) * h;
                x += (newRand1 - 0.5) * (offset + attempts * 10);
                y += (newRand2 - 0.5) * (offset + attempts * 10);
                attempts++;
              }

              location.x = Math.max(margin + 50, Math.min(this.displayWidth - margin - 50, x));
              location.y = Math.max(margin + 50, Math.min(this.displayHeight - margin - 50, y));
            }
          });
        }

        draw() {
          this.ctx.clearRect(0, 0, this.displayWidth, this.displayHeight);
          this.drawRoads();

          // Draw all locations
          gameState.game.locations.forEach((location, i) => {
            const isPlayer = i === gameState.game.location;
            const radius = 32;
            this.ctx.beginPath();
            this.ctx.arc(location.x, location.y, radius, 0, Math.PI * 2);
            this.ctx.fillStyle = isPlayer ? "#4a5a35" : "#2d2d20";
            this.ctx.fill();
            this.ctx.strokeStyle = isPlayer ? "#ffd700" : "#6a6a45";
            this.ctx.lineWidth = isPlayer ? 3 : 1;
            this.ctx.stroke();
            //emoji size
            this.ctx.font = "24px Consolas";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillStyle = "#f4e4bc";
            this.ctx.fillText(location.emoji, location.x, location.y);

            this.ctx.font = "12px Consolas";
            this.ctx.textBaseline = "top";
            this.ctx.fillText(location.name, location.x, location.y + radius + (Math.random() * (20 - 6 + 1) ));
          });

          // Redraw hover effect if still active
          if (this.hoverLocation !== null && this.hoverLocation !== gameState.game.location) {
            this.drawPathTo(this.hoverLocation);
            const loc = gameState.game.locations[this.hoverLocation];
            this.drawTooltip(loc.x + 50, loc.y, `${GridSystem.getGridDistance(gameState.game.location, this.hoverLocation)} days 🗺️`);
          }
        }

        drawRoads() {
          this.ctx.strokeStyle = "#8b7355";
          this.ctx.lineWidth = 2;
          gameState.game.locations.forEach((from, i) => {
            const distances = gameState.game.locations
              .map((to, j) => ({
                index: j,
                dist: Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2),
              }))
              .filter((d) => d.index !== i)
              .sort((a, b) => a.dist - b.dist)
              .slice(0, 2);
            distances.forEach(({ index }) => {
              const to = gameState.game.locations[index];
              const midX = (from.x + to.x) / 2;
              const midY = (from.y + to.y) / 2;
              const dx = to.x - from.x;
              const dy = to.y - from.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const perpX = (-dy / dist) * 20;
              const perpY = (dx / dist) * 20;
              this.ctx.beginPath();
              this.ctx.moveTo(from.x, from.y);
              this.ctx.quadraticCurveTo(midX + perpX, midY + perpY, to.x, to.y);
              this.ctx.stroke();
            });
          });
        }

        drawPathTo(targetIndex) {
          const path = GridSystem.findPath(gameState.game.location, targetIndex);
          if (path.length <= 1) return;

          this.ctx.save();
          this.ctx.strokeStyle = "rgba(212, 175, 55, 0.6)"; // Gold, soft
          this.ctx.lineWidth = 3;
          this.ctx.setLineDash([5, 10]);
          this.ctx.lineCap = "round";

          // Draw path
          this.ctx.beginPath();
          const startLoc = gameState.game.locations[path[0]];
          this.ctx.moveTo(startLoc.x, startLoc.y);
          for (let i = 1; i < path.length; i++) {
            const loc = gameState.game.locations[path[i]];
            this.ctx.lineTo(loc.x, loc.y);
          }
          this.ctx.stroke();

          // Add day markers (☀️) at each node except start
          for (let i = 1; i < path.length; i++) {
            const loc = gameState.game.locations[path[i]];
            this.ctx.font = "16px Arial";
            //this.ctx.fillText("☀️", loc.x - 8, loc.y - 20);
          }

          this.ctx.restore();
        }

        drawTooltip(x, y, text) {
          const padding = 8;
          const fontSize = 14;
          this.ctx.font = `bold ${fontSize}px Consolas`;
          const width = this.ctx.measureText(text).width + padding * 2;
          const height = fontSize + padding * 2;

          // Background box
          this.ctx.fillStyle = "rgba(40, 30, 20, 0.9)";
          this.ctx.fillRect(x, y - height, width, height);
          this.ctx.strokeStyle = "rgba(212, 175, 55, 0.7)";
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(x, y - height, width, height);

          // Text
          this.ctx.fillStyle = "#e8dcc5";
          this.ctx.fillText(text, x + width / 2, y - height + fontSize / 2);
        }

        handleClick(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          gameState.game.locations.forEach((location, i) => {
            const dist = Math.sqrt((x - location.x) ** 2 + (y - location.y) ** 2);
            if (dist <= 40) {
              if (i !== gameState.game.location) {
                travel(i);
              } else {
                enterLocation(i);
              }
            }
          });
        }

        handleMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          let hoverLocation = null;

          gameState.game.locations.forEach((location, i) => {
            const dist = Math.sqrt((x - location.x) ** 2 + (y - location.y) ** 2);
            if (dist <= 40 && i !== gameState.game.location) {
              hoverLocation = i;
            }
          });

          if (hoverLocation !== null) {
            this.hoverLocation = hoverLocation;
            this.canvas.style.cursor = "pointer";
            this.draw(); // Redraw with path and tooltip
          } else if (this.hoverLocation !== null) {
            this.hoverLocation = null;
            this.canvas.style.cursor = "default";
            this.draw(); // Clear hover effect
          }
        }
      }

      // Game Functions
      function travel(locationIndex) {
        // Calculate travel time using grid distance
        const travelTime = GridSystem.getGridDistance(gameState.game.location, locationIndex);

        if (gameState.game.day + travelTime > gameState.game.rules.gameplay.maxDays) {
          return;
        }

        gameState.setLocation(locationIndex);
        gameState.updateDay(travelTime);

        if (gameState.game.day > gameState.game.rules.gameplay.maxDays) {
          endGame();
          return;
        }

        MarketActions.updatePrices();
        MarketActions.updateStock();
        gameState.decaySaturation();
        updateUI();
      }

      function enterLocation(locationIndex) {
        updateUI();
        showTrading();
      }

      function canDeliverQuest() {
        if (!gameState.game.currentQuest) return false;

        const currentLocationName = gameState.getCurrentLocation().name;
        const targetMatch = currentLocationName === gameState.game.currentQuest.targetLocationName;
        const questItemCount = gameState.getInventoryCount(gameState.game.currentQuest.itemId);
        const hasEnoughItems = questItemCount >= gameState.game.currentQuest.quantity - gameState.game.currentQuest.delivered;

        return targetMatch && hasEnoughItems;
      }

      function deliverQuest() {
        if (!canDeliverQuest()) return;

        const quest = gameState.game.currentQuest;
        const questItemCount = gameState.getInventoryCount(quest.itemId);
        const deliverAmount = Math.min(questItemCount, quest.quantity - quest.delivered);

        // Remove items from inventory
        gameState.removeFromInventory(quest.itemId, deliverAmount);

        // Update quest progress
        gameState.updateQuestDelivered(deliverAmount);

        // Check if quest completed
        if (quest.delivered >= quest.quantity) {
          gameState.updateGold(quest.reward);
          gameState.completeQuest();

          // Generate new quest
          const newQuest = QuestLogic.generateQuest(gameState.game.location, gameState.game.seed, gameState.game.day);
          gameState.setQuest(newQuest);
        }

        updateUI();
        updateTradingUI();
      }

      function showMap() {
        document.getElementById("mapScreen").classList.remove("hidden");
        document.getElementById("tradingScreen").classList.add("hidden");
      }

      function showTrading() {
        document.getElementById("mapScreen").classList.add("hidden");
        document.getElementById("tradingScreen").classList.remove("hidden");
        updateTradingUI();
      }

      // Enhanced updateUI with quest integration
      function updateUI() {
        document.getElementById("day").textContent = gameState.game.day;
        document.getElementById("gold").textContent = gameState.getGold();
        document.getElementById("location").textContent = gameState.getCurrentLocation().name;
        document.getElementById("inventoryCount").textContent = `${gameState.game.inventory.length}/${gameState.game.rules.gameplay.inventoryLimit}`;

        updateInventory();
        updateNews();
        updateTradingUI();

        if (window.mapRenderer) mapRenderer.draw();
      }

      function updateInventory() {
        const inventory = document.getElementById("inventory");
        const items = {};

        gameState.game.inventory.forEach((item) => {
          items[item.id] = (items[item.id] || 0) + 1;
        });

        inventory.innerHTML =
          Object.keys(items).length === 0
            ? "<div>Empty</div>"
            : Object.entries(items)
                .map(([id, count]) => {
                  const item = gameState.getItem(id);
                  return `<div class="inventory-item">
                              <span class="inventory-item-icon">${item.emoji}</span>
                              <span class="inventory-item-text">${item.name}</span>
                              <span class="inventory-item-count">x${count}</span>
                          </div>`;
                })
                .join("");
      }

      // Enhanced updateNews with quest display
      function updateNews() {
        const newsContainer = document.getElementById("news");
        const items = [];

        // Quest status with delivery button
        if (gameState.game.currentQuest) {
          const questItem = gameState.getItem(gameState.game.currentQuest.itemId);
          const canDeliver = canDeliverQuest();

          // Quest status - always first
          if (gameState.game.currentQuest) {
            const questItem = gameState.getItem(gameState.game.currentQuest.itemId);
            items.push(`<div class="quest-item">
                          <div class="quest-title">Deliver ${questItem.name} to ${gameState.game.currentQuest.targetLocationName}</div>
                          <div class="quest-progress">Progress: ${gameState.game.currentQuest.delivered}/${gameState.game.currentQuest.quantity} ${questItem.name} delivered | Reward: ${gameState.game.currentQuest.reward} gold </div>
                          <!-- <div class="quest-reward">Reward: ${gameState.game.currentQuest.reward} g</div> -->
                      </div>`);
          }
        }

        // Market opportunities
        const current = gameState.getCurrentLocation();
        gameState.game.items.forEach((item) => {
          const price = MarketLogic.getPrice(item.id, gameState.game.location);
          const multiplier = current.multipliers[item.category];

          if (multiplier < 0.9) {
            items.push(`<div class="news-item market-opportunity">
                              ${item.emoji} Great ${item.name} prices here!
                          </div>`);
          }
        });

        // Fill with generic news
        const genericNews = gameState.game.gameData.genericNews;
        while (items.length < 6) {
          items.push(`<div class="news-item">${genericNews[Math.floor(Math.random() * genericNews.length)]}</div>`);
        }

        newsContainer.innerHTML = items.slice(0, 6).join("");
      }

      function updateTradingUI() {
        const items = document.getElementById("items");
        const currentLocation = gameState.getCurrentLocation();

        // Update header with location emoji
        const headerEmoji = document.querySelector(".header-left > div");
        headerEmoji.textContent = currentLocation.emoji;
        // Update location subtitle with flavor text
        document.querySelector(".location-subtitle").textContent = currentLocation.flavorText;

        // Update quest hint
        const questHint = document.getElementById("questHint");
        if (gameState.game.currentQuest) {
          const questItem = gameState.getItem(gameState.game.currentQuest.itemId);
          const canDeliver = canDeliverQuest();
          const owned = gameState.getInventoryCount(gameState.game.currentQuest.itemId);
          const needed = gameState.game.currentQuest.quantity - gameState.game.currentQuest.delivered;
          const buttonText = canDeliver ? "✅ Deliver" : "❌ Need More";
          const buttonDisabled = !canDeliver;

          questHint.innerHTML = `
      <div class="quest-banner">
        <div class="quest-icon">📋</div>
        <div class="quest-text">
          <div class="quest-title">Deliver ${questItem.name} to ${gameState.game.currentQuest.targetLocationName}</div>
          <div class="quest-progress">You have ${owned}, need ${needed}</div>
        </div>
        <button class="btn btn-quest" onclick="deliverQuest()" ${buttonDisabled ? "disabled" : ""}>
          ${buttonText}
        </button>
      </div>
    `;
        } else {
          questHint.textContent = "No active quest";
        }

        // Update market insight
        const insightText = document.getElementById("insightText");
        const goodDeals = gameState.game.items.filter((item) => {
          const multiplier = currentLocation.multipliers[item.category] || 1.0;
          return multiplier <= 0.9;
        });
        if (goodDeals.length > 0) {
          const avgDiscount = Math.round(
            (1 -
              goodDeals.reduce((sum, item) => {
                return sum + (currentLocation.multipliers[item.category] || 1.0);
              }, 0) /
                goodDeals.length) *
              100
          );
          insightText.textContent = `Great prices here! (${avgDiscount}% below average)`;
        } else {
          insightText.textContent = "Standard market prices";
        }

        // Generate item rows
        items.innerHTML = gameState.game.items
          .map((item) => {
            const price = MarketLogic.getPrice(item.id, gameState.game.location);
            const stock = gameState.getStock(item.id);
            const owned = gameState.getInventoryCount(item.id);
            const maxBuy = MarketLogic.getMaxBuyQuantity(item.id);
            const maxSell = MarketLogic.getMaxSellQuantity(item.id);
            const dealQuality = MarketLogic.getDealQuality(item.id);
            const avgPurchasePrice = gameState.getAveragePurchasePrice(item.id);

            // Deal indicator classes and text
            const dealClasses = {
              great: "deal-great",
              good: "deal-good",
              fair: "deal-fair",
              poor: "deal-poor",
            };
            const dealText = {
              great: "Great!",
              good: "Good",
              fair: "Fair",
              poor: "Poor",
            };

            const rowClasses = ["item-row"];
            if (dealQuality === "great" || dealQuality === "good") {
              rowClasses.push("good-deal");
            } else if (dealQuality === "poor") {
              rowClasses.push("bad-deal");
            }

            if (stock === 0) {
              rowClasses.push("no-stock");
            }

            // Item meta text
            let itemMeta = `Available: ${stock} | You own: <span class="owned-count">${owned}</span>`;
            if (gameState.game.currentQuest && gameState.game.currentQuest.itemId === item.id) {
              itemMeta += "<br>Perfect for your quest!";
            } else if (stock <= 2 && stock > 0) {
              itemMeta += "<br>Limited stock - act fast!";
            } else if (dealQuality === "poor") {
              itemMeta += "<br>Overpriced here - try elsewhere";
            } else if (dealQuality === "great") {
              itemMeta += "<br>Excellent value!";
            } else {
              itemMeta += "<br>Standard market price";
            }

            const displayPrice = stock === 0 ? "--" : `${price}g${avgPurchasePrice !== null ? ` (${avgPurchasePrice}g avg)` : ""}`;

            return `
        <div class="${rowClasses.join(" ")}">
          <!-- Item Visual -->
          <div class="item-visual">
            <div class="item-icon">${item.emoji}</div>
            <div class="deal-indicator ${dealClasses[dealQuality]}">${dealText[dealQuality]}</div>
          </div>

          <!-- Item Info -->
          <div class="item-info">
            <div class="item-header">
              ${item.name}<span class="item-price">${displayPrice}</span>
            </div>
            <div class="item-meta">${itemMeta}</div>
          </div>

          <!-- Buy Controls: Unified - BUY 1 + -->
          <div class="buy-controls">
            <div class="quantity-action-row">
              <button class="quantity-btn" 
                      onclick="changeQuantity('${item.id}', 'buy', -1)" 
                      ${maxBuy === 0 ? "disabled" : ""}>−</button>
              
              <button class="btn btn-buy action-button" 
                      onclick="executeTrade('${item.id}', 'buy')" 
                      ${maxBuy === 0 ? "disabled" : ""}
                      id="buy-button-${item.id}">
                BUY <span id="buy-${item.id}">1</span>
              </button>
              
              <button class="quantity-btn" 
                      onclick="changeQuantity('${item.id}', 'buy', 1)" 
                      ${maxBuy === 0 ? "disabled" : ""}>+</button>
            </div>

            <!-- Instant Buy All -->
            <button class="btn btn-buy action-button" 
                    onclick="quickBuyAll('${item.id}')"
                    ${maxBuy === 0 ? "disabled" : ""}>
              Buy All (${maxBuy})
            </button>
          </div>

          <!-- Sell Controls: Unified - SELL 1 + -->
          <div class="sell-controls">
            <div class="quantity-action-row">
              <button class="quantity-btn" 
                      onclick="changeQuantity('${item.id}', 'sell', -1)" 
                      ${maxSell === 0 ? "disabled" : ""}>−</button>
              
              <button class="btn btn-sell action-button" 
                      onclick="executeTrade('${item.id}', 'sell')" 
                      ${maxSell === 0 ? "disabled" : ""}
                      id="sell-button-${item.id}">
                SELL <span id="sell-${item.id}">1</span>
              </button>
              
              <button class="quantity-btn" 
                      onclick="changeQuantity('${item.id}', 'sell', 1)" 
                      ${maxSell === 0 ? "disabled" : ""}>+</button>
            </div>

            <!-- Instant Sell All -->
            <button class="btn btn-sell action-button" 
                    onclick="quickSellAll('${item.id}')"
                    ${maxSell === 0 ? "disabled" : ""}>
              Sell All (${maxSell})
            </button>
          </div>
        </div>
      `;
          })
          .join("");
      }

      function changeQuantity(itemId, type, delta) {
        const element = document.getElementById(`${type}-${itemId}`);
        let current = parseInt(element.textContent);
        current = Math.max(1, current + delta);

        if (type === "buy") {
          const maxBuy = MarketLogic.getMaxBuyQuantity(itemId);
          current = Math.min(current, maxBuy);
        } else {
          const maxSell = MarketLogic.getMaxSellQuantity(itemId);
          current = Math.min(current, maxSell);
        }

        element.textContent = current;
      }

      function executeTrade(itemId, type) {
        const quantity = parseInt(document.getElementById(`${type}-${itemId}`).textContent);

        if (type === "buy") {
          if (MarketLogic.canBuy(itemId, quantity)) {
            MarketActions.buy(itemId, quantity);
          }
        } else {
          if (MarketLogic.canSell(itemId, quantity)) {
            MarketActions.sell(itemId, quantity);
          }
        }

        updateUI();
        updateTradingUI();
      }

      function setMaxQuantity(itemId, type) {
        const max = type === "buy" ? MarketLogic.getMaxBuyQuantity(itemId) : MarketLogic.getMaxSellQuantity(itemId);
        const element = document.getElementById(`${type}-${itemId}`);
        if (max > 0) {
          element.textContent = max;
        }
      }

      // Instant Buy All
      function quickBuyAll(itemId) {
        const max = MarketLogic.getMaxBuyQuantity(itemId);
        if (max > 0) {
          MarketActions.buy(itemId, max);
          updateUI();
          updateTradingUI();
        }
      }

      // Instant Sell All
      function quickSellAll(itemId) {
        const max = MarketLogic.getMaxSellQuantity(itemId);
        if (max > 0) {
          MarketActions.sell(itemId, max);
          updateUI();
          updateTradingUI();
        }
      }

      function endGame() {
        const profit = gameState.game.gold - gameState.game.rules.gameplay.startingGold;
        document.getElementById("profit").textContent = profit;
        document.getElementById("gameOver").style.display = "flex";
      }

      function resetGame() {
        gameState.reset();
        generateLocations();

        // Generate initial quest
        const initialQuest = QuestLogic.generateQuest(gameState.game.location, gameState.game.seed, gameState.game.day);
        gameState.setQuest(initialQuest);

        MarketActions.updatePrices();
        MarketActions.updateStock();

        document.getElementById("gameOver").style.display = "none";
        showMap();
        updateUI();
      }

      // Seeded grid-based location generation
      function generateLocations() {
        let seedRng = gameState.game.seed;
        function seededRandom() {
          seedRng = (seedRng * 9301 + 49297) % 233280;
          return seedRng / 233280;
        }

        const gridWidth = gameState.game.rules.grid.width;
        const gridHeight = gameState.game.rules.grid.height;
        const centerX = Math.floor(gridWidth / 2);
        const centerY = Math.floor(gridHeight / 2);

        // Initialize grid
        gameState.game.locationGrid = Array(gridHeight)
          .fill()
          .map(() => Array(gridWidth).fill(null));

        const min = gameState.game.rules.worldGeneration.minLocations;
        const max = gameState.game.rules.worldGeneration.maxLocations;
        const locationCount = Math.floor(seededRandom() * (max - min + 1)) + min;

        const templates = gameState.game.gameData.locationTemplates;

        // Always include commons first at center
        gameState.game.locations = [{ ...templates[0] }];
        gameState.game.locationGrid[centerY][centerX] = 0;

        // Add other locations based on distance tiers
        const shuffled = templates.slice(1).sort(() => seededRandom() - 0.5);
        const selectedTemplates = shuffled.slice(0, locationCount - 1);

        selectedTemplates.forEach((template, index) => {
          const locationIndex = index + 1;
          const location = { ...template };

          // Determine distance range based on tier
          let minDist, maxDist;
          switch (template.distanceTier) {
            case 1:
              minDist = 1;
              maxDist = 2;
              break;
            case 2:
              minDist = 3;
              maxDist = 4;
              break;
            case 3:
              minDist = 5;
              maxDist = 7;
              break;
            case 4:
              minDist = 8;
              maxDist = 10;
              break;
            default:
              minDist = 2;
              maxDist = 4;
              break;
          }

          // Find valid positions at appropriate distance
          const validPositions = [];
          for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
              if (gameState.game.locationGrid[y][x] === null) {
                const dist = Math.abs(x - centerX) + Math.abs(y - centerY);
                if (dist >= minDist && dist <= maxDist) {
                  validPositions.push({ x, y });
                }
              }
            }
          }

          // Place at random valid position
          if (validPositions.length > 0) {
            const pos = validPositions[Math.floor(seededRandom() * validPositions.length)];
            gameState.game.locationGrid[pos.y][pos.x] = locationIndex;
            gameState.game.locations.push(location);
          } else {
            // Fallback: place anywhere available
            for (let y = 0; y < gridHeight; y++) {
              for (let x = 0; x < gridWidth; x++) {
                if (gameState.game.locationGrid[y][x] === null) {
                  gameState.game.locationGrid[y][x] = locationIndex;
                  gameState.game.locations.push(location);
                  break;
                }
              }
              if (gameState.game.locations.length > locationIndex) break;
            }
          }
        });
      }

      // Load game data from JSON files
      async function loadGameData() {
        try {
          // Load game rules
          const rulesResponse = await fetch("game_rules.json");
          gameState.game.rules = await rulesResponse.json();

          // Load game data
          const dataResponse = await fetch("game_data.json");
          gameState.game.gameData = await dataResponse.json();

          // Set items from game data
          gameState.game.items = gameState.game.gameData.items;

          return true;
        } catch (error) {
          console.error("Failed to load game data:", error);
          return false;
        }
      }

      // Initialize game
      async function init() {
        try {
          // Load data first
          const dataLoaded = await loadGameData();
          if (!dataLoaded) {
            throw new Error("Failed to load game data");
          }

          // Set initial gold from rules
          gameState.setGold(gameState.game.rules.gameplay.startingGold);

          generateLocations();

          // Generate initial quest
          const initialQuest = QuestLogic.generateQuest(gameState.game.location, gameState.game.seed, gameState.game.day);
          gameState.setQuest(initialQuest);

          MarketActions.updatePrices();
          MarketActions.updateStock();

          // Initialize map renderer
          const canvas = document.getElementById("canvas");
          window.mapRenderer = new MapRenderer(canvas);

          updateUI();
        } catch (error) {
          console.error("Failed to initialize game:", error);
        }
      }

      // Start the game
      init();
      window.dispatchEvent(new Event('resize'));
      window.dispatchEvent(new Event('resize'));
    </script>
  </body>
</html>


==================================================
FILE: styles.css
MODIFIED: 2025-08-31 00:36:09
TOKENS: [92m4,203[0m
==================================================

* {
    box-sizing: border-box;
}




body {
    margin: 0;
    padding: var(--game-padding);
    font-family: 'Consolas', monospace;
    background: var(--theme-bg-primary);
    color: var(--theme-text-primary);
    overflow: hidden;
    font-size: 10px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: geometricPrecision;
}

/* === 🧱 CSS VARIABLES: HIGH FANTASY MEDIEVAL THEME === */
:root {
    /* === 🔹 CORE THEME PALETTE (Medieval Fantasy) === */
    --theme-bg-primary: linear-gradient(135deg, #1a2a1a, #2d3d20);
    --theme-bg-secondary: linear-gradient(90deg, #3a2818, #5d4037);
    --theme-bg-panel: #3a2818;
    --theme-bg-content: #2c2418;
    --theme-bg-item: #383020;
    --theme-bg-quest: linear-gradient(135deg, #3a2818, rgba(93, 64, 55, 0.3));
    --theme-bg-inventory: #2c2418;

    --theme-border-primary: #5d4037;
    --theme-border-accent: #d4af37; /* Gold */
    --theme-border-quest: #8b7355; /* Bronze */

    --theme-text-primary: #e8dcc5;
    --theme-text-gold: #d4af37;
    --theme-text-quest: #c2a366;
    --theme-text-muted: #8b7355;
    --theme-text-highlight: #a67c52;
    --theme-text-bg-alpha: rgba(0, 0, 0, 0.4);

    /* === 🎨 MATERIAL INSPIRED COLORS === */
    --color-wood-dark: #4e3b27;
    --color-stone: #6b6b5b;
    --color-iron: #5a5a6a;
    --color-gold: #d4af37;
    --color-bronze: #b08d57;
    --color-emerald: #3a9d7f;
    --color-ruby: #9e1d22;
    --color-sapphire: #2a5ca8;

    /* === 📐 LAYOUT CONSTANTS === */
    --header-height: 70px;
    --panel-padding: 16px;
    --content-gap: 6px;
    --border-radius: 6px;
    --border-width: 2px;
    --game-padding: 16px;
    --item-padding: 4px;
    --shadow-game: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 0 2px rgba(212, 175, 55, 0.2);

    /* === 🔁 LEGACY ALIASES (For backward compatibility) === */
    --bg-primary: var(--theme-bg-primary);
    --bg-secondary: var(--theme-bg-secondary);
    --bg-tertiary: var(--theme-bg-panel);
    --bg-panel: var(--theme-bg-panel);
    --bg-item: var(--theme-bg-item);
    --bg-news: var(--theme-bg-content);
    --bg-inventory: var(--theme-bg-inventory);
    --border-primary: var(--theme-border-primary);
    --border-accent: var(--theme-border-accent);
    --text-primary: var(--theme-text-primary);
    --text-gold: var(--theme-text-gold);
    --text-muted: var(--theme-text-muted);
    --text-highlight: var(--theme-text-highlight);
}

/* === 🏗️ BASE LAYOUT === */
.game-container {
    width: 100%;
    height: calc(100vh - calc(var(--game-padding) * 2));
    /* height: 100%; */
    border: var(--border-width) solid var(--theme-border-accent);
    border-radius: var(--border-radius);
    overflow: hidden;
    background: var(--theme-bg-primary);
    box-shadow: var(--shadow-game);
    display: flex;
    flex-direction: column;
}

.screen {
    width: 100%;
    height: calc(100% - var(--header-height));
    flex: 1;
    display: flex;
    flex-direction: column;
}

.hidden {
    display: none;
}

/* === 📢 HEADER STYLES === */
.header {
    background: var(--theme-bg-secondary);
    padding: 12px 24px;
    border-bottom: 3px solid var(--theme-border-accent);
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: var(--header-height);
}

.header-left {
    display: flex;
    align-items: center;
    gap: var(--content-gap);
}

.location-display {
    display: flex;
    flex-direction: column;
    gap: var(--content-gap);
}

.location-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--theme-text-gold);
    text-shadow: var(--shadow-game);
}

.location-subtitle {
    font-size: 0.7rem;
    color: var(--theme-text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.header-stats {
    display: flex;
    gap: var(--content-gap);
    font-size: 0.7rem;
}

.stat-item {
    padding: var(--item-padding);
    background: var(--theme-text-bg-alpha);
    border-radius: var(--border-radius);
    border: var(--border-width) solid var(--theme-border-primary);
}

.stat-label {
    color: var(--theme-text-muted);
}

.stat-value {
    color: var(--theme-text-gold);
    font-weight: bold;
}

/* === 🗺️ MAP AREA === */
#mapArea {
    height: 60%;
    cursor: pointer;
}

canvas {
  width: 100%;
  height: 100%;
  image-rendering: -webkit-optimize-contrast; /* Optional: crisper edges */
}

/* === 📦 PANELS LAYOUT === */
.panels {
    height: 40%;
    display: flex;
}

.panel {
    padding: var(--panel-padding);
    background: var(--theme-bg-panel);
    border: var(--border-width) solid var(--theme-border-primary);
    display: flex;
    flex-direction: column;
}

.news-panel {
    flex: 2;
    border-right: 1px solid var(--theme-border-primary);
}

.inventory-panel {
    flex: 1;
}

.panel h3 {
    margin: 0 0 12px 0;
    color: var(--theme-text-gold);
    font-size: 0.8rem;
    text-shadow: var(--shadow-game);
    border-bottom: var(--border-width) solid var(--theme-border-accent);
    padding-bottom: 8px;
}

.panel-content {
    flex: 1;
    overflow-y: auto;
    min-height: 0;
}

/* === 📜 QUEST STYLING === */
.quest-item {
    background: var(--theme-bg-quest);
    border: var(--border-width) solid var(--theme-border-quest);
    border-radius: var(--border-radius);
    padding: 12px;
    margin: 8px 0;
    position: relative;
}

.quest-item::before {
    content: "📋";
    position: absolute;
    top: -10px;
    left: -2px;
    background: var(--theme-border-quest);
    width: 18px;
    height: 18px;
    border-radius: var(--border-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    border: var(--border-width) solid var(--theme-border-accent);
}

.quest-title {
    color: var(--theme-text-quest);
    font-weight: bold;
    margin-bottom: 4px;
    font-size: 0.8rem;
}

.quest-progress {
    color: var(--theme-text-highlight);
    font-size: 0.8rem;
}

.quest-reward {
    color: var(--theme-text-muted);
    font-size: 0.8rem;
    margin-top: 4px;
}

.quest-status {
    display: flex;
    align-items: center;
    gap: var(--content-gap);
    font-size: 0.8rem;
}

.quest-status::before {
    content: "📋";
    position: absolute;
    top: -8px;
    left: 8px;
    background: var(--theme-border-quest);
    width: 20px;
    height: 20px;
    border-radius: var(--border-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    border: var(--border-width) solid var(--theme-border-accent);
    z-index: 2;
}

.quest-status::after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    width: 60px;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(139, 69, 19, 0.3));
    pointer-events: none;
}

.status-icon {
    font-size: 0.8rem;
    color: var(--color-ruby);
}

.status-text {
    color: var(--theme-text-muted);
    font-weight: bold;
}

/* === 📰 NEWS & MARKET ITEMS === */
.news-item {
    background: var(--theme-bg-content);
    border: 1px solid var(--theme-border-primary);
    border-radius: var(--border-radius);
    padding: 12px;
    margin: 8px 0;
    font-size: 0.8rem;
    border-left: 4px solid var(--theme-border-accent);
}

.market-opportunity {
    border-left-color: var(--color-emerald);
}

.market-insight {
    background: var(--theme-bg-panel);
    border: 1px solid var(--theme-border-primary);
    border-radius: var(--border-radius);
    padding: 12px;
    margin: 8px 0;
    font-size: 0.8rem;
    border-left: 4px solid var(--theme-text-highlight);
    display: flex;
    align-items: center;
    gap: var(--content-gap);
}

/* === 🎒 INVENTORY STYLES === */
.inventory-count {
    color: var(--theme-text-muted);
    font-size: 0.8rem;
}

.inventory-item {
    display: flex;
    align-items: center;
    gap: var(--content-gap);
    padding: 8px;
    background: var(--theme-bg-item);
    border-radius: var(--border-radius);
    margin: 8px 0;
    border: 1px solid var(--theme-border-primary);
}

.inventory-item-icon {
    font-size: 1.2rem;
}

.inventory-item-text {
    flex: 1;
}

.inventory-item-count {
    color: var(--theme-text-muted);
    font-size: 0.8rem;
}

/* === 💱 TRADING SCREEN === */
.trading-screen {
    padding: var(--panel-padding);
    background: var(--theme-bg-panel);
    overflow-y: auto;
    flex: 1;
    display: flex;
    flex-direction: column;
}

.trading-screen h2 {
    color: var(--theme-text-gold);
    text-align: center;
    margin-bottom: 12px;
    font-size: 1.3rem;
    text-shadow: var(--shadow-game);
}

.quest-hint {
    color: var(--theme-text-quest);
    font-size: 0.8rem;
}

.items-container {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
    margin-bottom: 16px;
    min-height: 0;
}

.item-row {
    display: grid;
    grid-template-columns: auto 1fr auto auto;
    gap: calc(var(--content-gap) + 0px);
    align-items: center;
    padding: 1px 12px;
    margin: 2px 0;
    background: var(--theme-bg-item);
    border-radius: var(--border-radius);
    border-left: 3px solid var(--theme-border-primary);
    transition: all 0.2s;
}

.item-row:hover {
    transform: translateX(4px);
    box-shadow: 4px 4px 12px rgba(0, 0, 0, 0.3);
}

.item-row.good-deal {
    border-left-color: var(--color-emerald);
    background: var(--theme-bg-content);
}

.item-row.bad-deal {
    border-left-color: var(--color-ruby);
    background: linear-gradient(135deg, var(--theme-bg-item), rgba(158, 29, 34, 0.1));
}

.item-visual {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: var(--content-gap);
}

.item-icon {
    font-size: 2rem;
    filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
}

.deal-indicator {
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: var(--border-radius);
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    min-width: 45px;
    text-align: center;
}

.deal-great {
    background: var(--color-emerald);
    color: var(--theme-bg-primary);
}

.deal-good {
    background: var(--color-bronze);
    color: var(--theme-text-primary);
}

.deal-fair {
    background: var(--theme-border-primary);
    color: var(--theme-text-muted);
}

.deal-poor {
    background: var(--color-ruby);
    color: white;
}

.item-info {
    flex: 1;
}

.item-header {
    color: var(--theme-text-gold);
    display: flex;
    align-items: center;
    font-size: 1.0rem;
    font-weight: bold;
    margin-bottom: 4px;
}

.item-price {
    color: var(--theme-text-gold);
    font-weight: bold;
    font-size: 0.8rem;
    margin-left: 6px;
}

.item-meta {
    color: var(--theme-text-muted);
    font-size: 0.8rem;
    line-height: 1.3;
}

.owned-count {
    color: var(--theme-text-gold);
    font-weight: bold;
}

/* === BUTTONS === */
.btn {
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-weight: bold;
    font-family: inherit;
    transition: all 0.2s ease;
    padding: 6px 12px;
    font-size: 0.8rem;
    flex: 1;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.btn-primary {
    background: var(--color-wood-dark);
    color: var(--theme-text-gold);
}

.btn-buy {
    background: var(--theme-border-accent);
    color: var(--theme-bg-primary);
}

.btn-sell {
    background: var(--color-ruby);
    color: var(--theme-text-primary);
}

.btn-back {
    background: var(--theme-border-primary);
    color: var(--theme-text-gold);
}

.btn-quest {
    background: var(--theme-border-primary);
    color: var(--theme-text-primary);
    margin-top: 8px;
    padding: 8px 12px;
    font-size: 0.8rem;
    width: 100%;
}

.btn-quest:disabled {
    background: var(--theme-border-primary);
    color: var(--theme-text-muted);
}

/* === FOOTER & SCROLLBAR === */
.trading-footer {
    padding: 12px;
    border-top: var(--border-width) solid var(--theme-border-accent);
    background: var(--theme-bg-secondary);
    text-align: center;
    flex-shrink: 0;
}

.no-stock {
    opacity: 0.6;
}

.items-container::-webkit-scrollbar {
    width: 8px;
}

.items-container::-webkit-scrollbar-track {
    border-radius: var(--border-radius);
}

.items-container::-webkit-scrollbar-thumb {
    background: var(--theme-border-accent);
    border-radius: var(--border-radius);
}

.items-container::-webkit-scrollbar-thumb:hover {
    background: var(--theme-text-gold);
}

/* === GAME OVER SCREEN === */
.game-over {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: var(--theme-text-bg-alpha);
    display: none;
    align-items: center;
    justify-content: center;
    text-align: center;
}

/* === QUEST BANNER === */
.quest-banner {
    background: var(--theme-bg-quest);
    border: var(--border-width) solid var(--theme-border-quest);
    border-radius: var(--border-radius);
    padding: var(--game-padding);
    display: flex;
    align-items: center;
    gap: var(--content-gap);
    position: relative;
    overflow: hidden;
    flex-wrap: wrap;
}

.quest-icon {
    font-size: 1.2rem;
    color: var(--theme-text-gold);
    filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
}

.quest-text {
    flex: 1;
    min-width: 0;
}

#questHint {
    color: var(--theme-text-quest);
    font-size: 0.95rem;
    line-height: 1.4;
    padding-left: 4px;
}













/* Unified quantity-action row */
.quantity-action-row {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-bottom: 6px;
}

/* Make the middle button wider and more prominent */
.action-button {
  font-size: 0.9rem;
  font-weight: bold;
  padding: 8px 12px;
  flex: 1;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Press animation */
.btn:active {
  transform: translateY(1px);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

/* Buy All / Sell All styling */
.btn-buy-all,
.btn-sell-all {
  font-size: 0.8rem;
  padding: 6px;
  border: 1px solid var(--theme-border-accent);
}

